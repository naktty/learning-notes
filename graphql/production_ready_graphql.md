# スキーマ設計
## Naming
* 命名の一貫性が重要
* クライアントが予測可能な名称にする
* 使用する名詞や動詞に一貫性を持たせるべき
* できるだけ具体的にしてクライアントの混乱を避ける
  * 「User」や「Event」のような一般的または汎用的な名前は良くない

## Descriptions
* スキーマがよく設計されていれば、descriptionsはほとんど不要のはず
* ユーザーのユースケースに対する理解をdescriptionsに依存させないことが重要

## スキーマを使いやすく・理解しやすくする方法
* 可能な限りフィールドは1つのことに特化する。
* スキーマが強制できる場合は、サーバーサイド実行時ロジック（バリデーションや変換）を避ける。
  * enumを利用して許容する状態を明確にする
  * nullが許容できない場合は!をつける
* デフォルト値を使用して、オプションの入力や引数を使用する際のデフォルトの動作を示す。

## ページネーション
* オフセット
  * 「何件目から何件取得するか」を指定する方法
  * データの更新でページ間の整合性が崩れる可能性有

* カーソル（通常はこちらで実装すべき）
  * 各アイテムに一意の識別子（カーソル）を付与し、そのカーソル以降のデータを取得する方法
  * データが変動してもズレが生じない

## 「nullを許容するかどうか」を決める際のガイドライン
* 引数について
  * 基本的に、引数は必ず値が渡されるように（non-null）すると、APIが予測しやすくなり、使いやすくなる
  * ただし、新しく引数を追加する場合は、既存のクライアントを壊さないようにnullableにするのがベスト
* データ取得に失敗する可能性があるフィールド
  * データベースの関連付けやネットワーク呼び出しなど、将来エラーが起こりうるフィールドは、失敗時にnullを返せるようにnullableにしておくと安全
* すでに親オブジェクトでロード済みのシンプルなスカラー値
  * 実行時にすでに値が存在することが保証されているため、non-nullにしても問題ない

## Abstract Types
### インターフェース
* 振る舞いを共有するものに対して共通の仕様（ルール）を提供するものであるべき
* 複数の型がいくつかのフィールドを共有しているが、これらの型が共通の振る舞いを共有していない場合、単にインターフェイスを混在させる誘惑を避けるべき
* 強い意味を持たないインターフェースの命名はぎこちなくなる

### ユニオン
あるフィールドが異なる型を返す可能性があるが、それらの型が必ずしも共通の振る舞いを持つとは限らない場合に使用する

## 静的クエリの設計
GraphQLでは、クエリを直接文字列として記述する「静的クエリ（static query）」の設計が推奨されている。
なぜ静的クエリが良いのか？

* コードの可読性が向上する
  * 静的クエリなら、ソースコードを見ただけでどのフィールドが必要なのか、どのような形のデータが返ってくるのかが一目瞭然
* ツールの恩恵を受けられる
  * 静的なクエリは、IDEによる補完やエラーチェック、コード生成ツールとの連携が容易になる
* サーバーとの契約が明確になる
  * 静的クエリは変更されないため、デプロイ前にどのクエリが送信されるかを正確に把握でき、クライアントとサーバー間の契約が明確になる
* ログや解析が容易になる
  * クエリに名前を付けておくと、サーバー側でのログ収集や、どのクエリが頻繁に使われているかの解析がシンプルになる

## Mutation
### Relayの慣習
各Mutationに対して「ひとつの必須の入力型（input type）」を使うことが推奨される。

**メリット**
* 進化しやすい（Evolvability）
  * ひとつのinput型にまとめることで、後からフィールドを追加・変更する際、Mutation自体のシグネチャを大きく変える必要がなくなる。
* クライアント側が使いやすい
  * 複数の引数を個別に渡すのではなく、ひとつの変数（inputオブジェクト）で済むため、クライアント側のコードがシンプルになる。
* APIの一貫性
  * 同じパターンを使うことで、API全体での統一感が生まれ、他のAPIと合わせて理解しやすくなる。

## エラー
### エラーに含まれる情報
* message: エラーの内容を説明する文字列
* locations: クエリ内のエラー発生箇所（行や列）
* path: どのフィールドでエラーが起きたかを示すパス
* extensions: エラーコードなど追加情報を入れるためのフィールド

### エラーの種類
* 開発者／クライアントエラー
  * ネットワークのタイムアウト、IDの形式が正しくない、レート制限など、クライアント側が対処するべきエラー等
  * これらはGraphQLのerrorsフィールドに含まれ、開発者がデバッグやロギングに利用する。
* ユーザーエラー
  * 例えば、「メールアドレスが既に使われています」や「チェックアウトを二重に行おうとした」など、ビジネスルールに基づくエラー
  * これらはエラーとしてレスポンスのerrorsに入れると、Mutation全体がnullになってしまい、クライアントにデータが返せなくなる
  * そのため、**ユーザーエラーはGraphQLスキーマの一部として、Mutationのペイロードにエラー情報を含める設計が推奨される。**

## スキーマ編成
### Mutation
* 突然変異の名前には、以下のような具体的で読みやすい名前を使うことを恐れないでほしい。
* cartProductAddのようなものではなく、addProductsToCartです。

### データ駆動型スキーマ vs ユースケース駆動型スキーマ

**データ駆動型スキーマ**

データそのものに焦点を当てて設計されたスキーマ。
クライアントが必要な情報だけを素早く取得するために作られます。
例えば、「全てのコメントを取得する」など、特定のデータを大量に取得するユースケースです。

**ユースケース駆動型スキーマ**

使いたい機能に焦点を当てて設計されたスキーマ。
ユーザーが特定のアクションを実行するために設計されたもの。
例えば、「GitHubで問題を開く」「プルリクエストをマージする」といったビジネスロジックに関連する機能です。

**GraphQL でのデータ駆動型ユースケースの課題**
* ページネーション
  * データを大量に取得したい場合、ページネーション（データを分割して送る）が邪魔になることがある。
  * 例えば、クライアントが全てのコメントを一度に取り出したい場合、ページネーションにより取得が分割され、効率が悪くなる。
* タイムアウトと制限
  * 大きなリクエストを送ると、サーバーがタイムアウトでリクエストを切断したり、レート制限がかかってしまう可能性が高い。
  * 大量のデータを取得しようとするデータ駆動型クライアントは、これらの制限により困難を伴う。

## Summary
GraphQLスキーマを設計する際に特に重要な4つのポイントは下記のとおり
1. デザインファーストのアプローチを採用する
    * スキーマの開発では、まず設計を重視。ドメイン知識を持つチームメンバーと議論し、実装の細かい部分は後回しにする。
2. クライアントのユースケースを基準に設計する
    * データ構造や型、フィールド単位で考えるのではなく、クライアントがどのようにAPIを使うかを意識して設計する。
3. スキーマをできるだけ表現力豊かにする
    * スキーマ自体がクライアントにとって「正しい使い方」を示すように設計する。ドキュメントは補足的な役割として考えるべき。
4. 汎用的すぎるスキーマを避ける
    * 「賢い」設計にこだわらず、特定のユースケースに適した明確なフィールドや型を作ることが大切。

#  GraphQLサーバーの実装
## スキーマの構築
できるだけコードファーストでスキーマを構築することがおすすめ

## リゾルバーデザイン
* シンプルであるべき
  * いいリゾルバーは少ないコードで書かれ、主にユーザーからの入力を処理し、ドメイン層（アプリケーションのビジネスロジック）にアクセスして、結果をAPIに返す形になる。
* ビジネスロジックを分ける
  * GraphQLリゾルバーが全てのロジックを処理するのではなく、ドメイン層にビジネスロジックを集中させることが重要。
  * リゾルバーはあくまで「インターフェース」として機能すべきで、ビジネスロジックを直接扱うべきではない。
* 一貫性の維持
  * GraphQL APIは、アプリケーション内の唯一のインターフェースではないことが多い。たとえば、同じビジネスロジックがUIやREST API、マイクロサービス間でも使われているかもしれない。
  * すべてが一貫性を保つためには、ロジックを複数の場所で管理しない方が良い。GraphQLのリゾルバーでロジックを大量に処理しない方が、システム全体の整合性を保てる。

### コンテキストオブジェクトに注意
* GraphQLの「コンテキストオブジェクト」は、リクエストの情報を保存するために非常に便利。例えば、リクエストのIPアドレスや認証情報を保存するのに使う。
* ただ、コンテキストに依存しすぎると、APIが予測できなくなったり、テストが難しくなったりする。
* コンテキストをクエリ実行中に変更することも避けるべき。コンテキストに新しい情報を追加すると、リゾルバーの順番に依存してしまい、システムが複雑になって予期しない動作を引き起こすことがあある。
* コンテキストの中身を厳選するべき。また、クエリを実行する前に、コンテキストの特定の部分を必須にするのも良いアイデアかもしれない。

### Summary
優れたリゾルバーを書くには
* GraphQLレイヤーからビジネスロジックをできるだけ排除する。
* コンテキストの引数はできるだけ不変にしておくこと。
* フィールドが特定の順序で呼び出されることに依存したり、コンテ
キストの特定の値が他のフィールドによって入力されたと思い込ん
だりしない。

p82 p145
