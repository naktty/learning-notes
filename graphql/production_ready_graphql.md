# スキーマ設計
## Naming
* 命名の一貫性が重要
* クライアントが予測可能な名称にする
* 使用する名詞や動詞に一貫性を持たせるべき
* できるだけ具体的にしてクライアントの混乱を避ける
  * 「User」や「Event」のような一般的または汎用的な名前は良くない

## Descriptions
* スキーマがよく設計されていれば、descriptionsはほとんど不要のはず
* ユーザーのユースケースに対する理解をdescriptionsに依存させないことが重要

## スキーマを使いやすく・理解しやすくする方法
* 可能な限りフィールドは1つのことに特化する。
* スキーマが強制できる場合は、サーバーサイド実行時ロジック（バリデーションや変換）を避ける。
  * enumを利用して許容する状態を明確にする
  * nullが許容できない場合は!をつける
* デフォルト値を使用して、オプションの入力や引数を使用する際のデフォルトの動作を示す。

## ページネーション
* オフセット
  * 「何件目から何件取得するか」を指定する方法
  * データの更新でページ間の整合性が崩れる可能性有

* カーソル（通常はこちらで実装すべき）
  * 各アイテムに一意の識別子（カーソル）を付与し、そのカーソル以降のデータを取得する方法
  * データが変動してもズレが生じない

## 「nullを許容するかどうか」を決める際のガイドライン
* 引数について
  * 基本的に、引数は必ず値が渡されるように（non-null）すると、APIが予測しやすくなり、使いやすくなる
  * ただし、新しく引数を追加する場合は、既存のクライアントを壊さないようにnullableにするのがベスト
* データ取得に失敗する可能性があるフィールド
  * データベースの関連付けやネットワーク呼び出しなど、将来エラーが起こりうるフィールドは、失敗時にnullを返せるようにnullableにしておくと安全
* すでに親オブジェクトでロード済みのシンプルなスカラー値
  * 実行時にすでに値が存在することが保証されているため、non-nullにしても問題ない

## Abstract Types
### インターフェース
* 振る舞いを共有するものに対して共通の仕様（ルール）を提供するものであるべき
* 複数の型がいくつかのフィールドを共有しているが、これらの型が共通の振る舞いを共有していない場合、単にインターフェイスを混在させる誘惑を避けるべき
* 強い意味を持たないインターフェースの命名はぎこちなくなる

### ユニオン
あるフィールドが異なる型を返す可能性があるが、それらの型が必ずしも共通の振る舞いを持つとは限らない場合に使用する

## 静的クエリの設計
GraphQLでは、クエリを直接文字列として記述する「静的クエリ（static query）」の設計が推奨されている。
なぜ静的クエリが良いのか？

* コードの可読性が向上する
  * 静的クエリなら、ソースコードを見ただけでどのフィールドが必要なのか、どのような形のデータが返ってくるのかが一目瞭然
* ツールの恩恵を受けられる
  * 静的なクエリは、IDEによる補完やエラーチェック、コード生成ツールとの連携が容易になる
* サーバーとの契約が明確になる
  * 静的クエリは変更されないため、デプロイ前にどのクエリが送信されるかを正確に把握でき、クライアントとサーバー間の契約が明確になる
* ログや解析が容易になる
  * クエリに名前を付けておくと、サーバー側でのログ収集や、どのクエリが頻繁に使われているかの解析がシンプルになる

## Mutation
### Relayの慣習
各Mutationに対して「ひとつの必須の入力型（input type）」を使うことが推奨される。

**メリット**
* 進化しやすい（Evolvability）
  * ひとつのinput型にまとめることで、後からフィールドを追加・変更する際、Mutation自体のシグネチャを大きく変える必要がなくなる。
* クライアント側が使いやすい
  * 複数の引数を個別に渡すのではなく、ひとつの変数（inputオブジェクト）で済むため、クライアント側のコードがシンプルになる。
* APIの一貫性
  * 同じパターンを使うことで、API全体での統一感が生まれ、他のAPIと合わせて理解しやすくなる。

## エラー
### エラーに含まれる情報
* message: エラーの内容を説明する文字列
* locations: クエリ内のエラー発生箇所（行や列）
* path: どのフィールドでエラーが起きたかを示すパス
* extensions: エラーコードなど追加情報を入れるためのフィールド

### エラーの種類
* 開発者／クライアントエラー
  * ネットワークのタイムアウト、IDの形式が正しくない、レート制限など、クライアント側が対処するべきエラー等
  * これらはGraphQLのerrorsフィールドに含まれ、開発者がデバッグやロギングに利用する。
* ユーザーエラー
  * 例えば、「メールアドレスが既に使われています」や「チェックアウトを二重に行おうとした」など、ビジネスルールに基づくエラー
  * これらはエラーとしてレスポンスのerrorsに入れると、Mutation全体がnullになってしまい、クライアントにデータが返せなくなる
  * そのため、**ユーザーエラーはGraphQLスキーマの一部として、Mutationのペイロードにエラー情報を含める設計が推奨される。**

## スキーマ編成
### Mutation
* 突然変異の名前には、以下のような具体的で読みやすい名前を使うことを恐れないでほしい。
* cartProductAddのようなものではなく、addProductsToCartです。

### データ駆動型スキーマ vs ユースケース駆動型スキーマ

**データ駆動型スキーマ**

データそのものに焦点を当てて設計されたスキーマ。
クライアントが必要な情報だけを素早く取得するために作られます。
例えば、「全てのコメントを取得する」など、特定のデータを大量に取得するユースケースです。

**ユースケース駆動型スキーマ**

使いたい機能に焦点を当てて設計されたスキーマ。
ユーザーが特定のアクションを実行するために設計されたもの。
例えば、「GitHubで問題を開く」「プルリクエストをマージする」といったビジネスロジックに関連する機能です。

**GraphQL でのデータ駆動型ユースケースの課題**
* ページネーション
  * データを大量に取得したい場合、ページネーション（データを分割して送る）が邪魔になることがある。
  * 例えば、クライアントが全てのコメントを一度に取り出したい場合、ページネーションにより取得が分割され、効率が悪くなる。
* タイムアウトと制限
  * 大きなリクエストを送ると、サーバーがタイムアウトでリクエストを切断したり、レート制限がかかってしまう可能性が高い。
  * 大量のデータを取得しようとするデータ駆動型クライアントは、これらの制限により困難を伴う。

## Summary
GraphQLスキーマを設計する際に特に重要な4つのポイントは下記のとおり
1. デザインファーストのアプローチを採用する
    * スキーマの開発では、まず設計を重視。ドメイン知識を持つチームメンバーと議論し、実装の細かい部分は後回しにする。
2. クライアントのユースケースを基準に設計する
    * データ構造や型、フィールド単位で考えるのではなく、クライアントがどのようにAPIを使うかを意識して設計する。
3. スキーマをできるだけ表現力豊かにする
    * スキーマ自体がクライアントにとって「正しい使い方」を示すように設計する。ドキュメントは補足的な役割として考えるべき。
4. 汎用的すぎるスキーマを避ける
    * 「賢い」設計にこだわらず、特定のユースケースに適した明確なフィールドや型を作ることが大切。

#  GraphQLサーバーの実装
## スキーマの構築
できるだけコードファーストでスキーマを構築することがおすすめ

## リゾルバーデザイン
* シンプルであるべき
  * いいリゾルバーは少ないコードで書かれ、主にユーザーからの入力を処理し、ドメイン層（アプリケーションのビジネスロジック）にアクセスして、結果をAPIに返す形になる。
* ビジネスロジックを分ける
  * GraphQLリゾルバーが全てのロジックを処理するのではなく、ドメイン層にビジネスロジックを集中させることが重要。
  * リゾルバーはあくまで「インターフェース」として機能すべきで、ビジネスロジックを直接扱うべきではない。
* 一貫性の維持
  * GraphQL APIは、アプリケーション内の唯一のインターフェースではないことが多い。たとえば、同じビジネスロジックがUIやREST API、マイクロサービス間でも使われているかもしれない。
  * すべてが一貫性を保つためには、ロジックを複数の場所で管理しない方が良い。GraphQLのリゾルバーでロジックを大量に処理しない方が、システム全体の整合性を保てる。

### コンテキストオブジェクトに注意
* GraphQLの「コンテキストオブジェクト」は、リクエストの情報を保存するために非常に便利。例えば、リクエストのIPアドレスや認証情報を保存するのに使う。
* ただ、コンテキストに依存しすぎると、APIが予測できなくなったり、テストが難しくなったりする。
* コンテキストをクエリ実行中に変更することも避けるべき。コンテキストに新しい情報を追加すると、リゾルバーの順番に依存してしまい、システムが複雑になって予期しない動作を引き起こすことがあある。
* コンテキストの中身を厳選するべき。また、クエリを実行する前に、コンテキストの特定の部分を必須にするのも良いアイデアかもしれない。

### Summary
優れたリゾルバーを書くには
* GraphQLレイヤーからビジネスロジックをできるだけ排除する。
* コンテキストの引数はできるだけ不変にしておくこと。
* フィールドが特定の順序で呼び出されることに依存したり、コンテ
キストの特定の値が他のフィールドによって入力されたと思い込ん
だりしない。

## テスト
テストをしやすくする最も重要なポイントは「リゾルバの設計をシンプルにすること」

### 統合テスト
* フィールドの取得テスト
* 全てのフィールドを含むクエリのテスト
* 認可のテスト

### リゾルバーの単体テストで注意すべき事項
* GraphQL の型変換（Type Coercion）
* ミドルウェアやプラグインの影響
* context オブジェクトの扱い
* parent オブジェクトのモック

## Summary
GraphQLサーバー実装の基本的な原則
*	拡張性の高いコードファースト（Code-First）フレームワークを優先する
    *	メタデータ、プラグイン、ミドルウェアの追加が容易なフレームワークを選ぶことで、柔軟な開発が可能になる。
*	GraphQLレイヤーは可能な限り薄く保ち、ビジネスロジックは独自のドメインレイヤーに移す
    *	GraphQLはあくまでAPIのインターフェースであり、ビジネスロジックをリゾルバに埋め込むのではなく、独立したドメインレイヤーに分離する。
*	リゾルバをできるだけシンプルにし、グローバルな可変状態に依存しない
    *	ステートレスな設計を心がけることで、デバッグやテストが容易になる。
*	モジュール化は必要になった時点で行う。特定のフレームワークにこだわらず、プログラミング言語の特性を活用する
    *	無理に早い段階で分割せず、コードが複雑になり始めたら適切なモジュール化を行う。
*	ドメインロジックのほとんどはドメインレイヤーでテストする。GraphQLサーバーのテストでは統合テストが最もコストパフォーマンスが高い
    *	単体テストではなく、GraphQLのクエリ全体をテストする統合テストを重視する。
*	実行時の条件によってスキーマを少し変える場合は可視性フィルター（Visibility Filters）を使う。ただし、大きく異なるスキーマが必要な場合は、ビルド時に別のサーバーを構築することも検討する
    *	例えば、認可によって特定のフィールドを非表示にする場合は可視性フィルターを活用し、まったく異なるAPIが必要なら独立したGraphQLサーバーを作る。

# セキュリティ
## レート制限
GraphQL APIが効果的にクライアントをレート制限するためのテクニックは下記のとおり
### 複雑性ベースのアプローチ
* 複雑性（コスト）の計算
    * クエリごとにコストを計算し、リクエスト数だけでなく、サーバー負荷に基づいてレートリミットを設定する。
* オブジェクト単位でコストを計算
    * スカラーフィールドは軽いため、オブジェクト（ノード）単位で計算する方が良い。
* ページネーションを活用
    * リスト型データはページネーションを使用し、クエリのコストを予測しやすくする。これにより、大量データの取得を制限できる。
* 動的 vs 静的なレートリミット
    * 動的なコスト計算は不安定になりがちなので、静的なコスト設定（固定値）が推奨される。
* 高コストなクエリの事前拒否
    * クエリ実行前にコストを計算し、過度に負荷の高いクエリを実行する前に拒否する。
* ツールの活用
    * GraphQL RubyのAnalyzer API や、JavaScriptの graphql-query-complexity などのツールを使用して、クエリの複雑性を解析する。

### 時間ベースのアプローチ
クエリの実行時間を基にサーバーの負荷を評価する方法。この方法はサーバーコストをより正確に反映し、通常ミドルウェアで実装され、リクエストからレスポンスまでのミリ秒数を計測します。

* 利点
	*	サーバーコストの正確な評価ができる。
	*	実行時間に基づくため、シンプルに実装可能。

* 問題点
	* サーバー応答時間が変動するため、同じクエリでも遅い時間帯にはレート制限される可能性がある。
	* クライアントは実行時間を予測できず、デプロイ後に調整が必要で予測が難しい。

### レートリミットの公開
* 目的
  * クライアントが自身のリクエストがレートリミット内か、制限を超える前にどれくらい残っているかを知るために、APIレスポンスにレートリミットの情報を提供する。
* 方法
  * 一般的にはレスポンスヘッダーで提供され、例えばGitHubのAPIでは、リクエスト制限、残りリクエスト数、リセット時間などを通知。
* GraphQLでの実装
  * GitHubのGraphQL APIではrateLimitフィールドを使い、クエリ実行時にそのコストや制限情報を取得可能。dryRun引数を使えば、実際にデータを取得せずに計算結果だけを確認できる。
* 注意点
  * クライアントがレートリミットを回避しようとする可能性があり、システムが正確に情報を提供するのが難しい場合もある。そのため、クライアントには適切に対応できるよう教育が必要。

## 悪意のあるクエリのブロック
GraphQLのクエリがサーバーに過剰な負荷をかけないようにするために、以下の制限方法がある
* 深さ制限（Depth Limit）
  * クエリが過度に深くネストされるのを防ぐ。例えば、クエリの最大深さを制限して、サーバー負荷を軽減する。
* 幅制限（Breadth Limit）
  * 同じリソースを複数回リクエストすることを防ぐ。複数のリソースを一度にリクエストする場合に制限を設ける。
* ノード制限（Node Limit）
  * クエリ内で要求されるオブジェクト数を制限し、過剰なリソース要求を防ぐ。
* バイトサイズ制限（Byte Size Limit）
  * クエリや変数のサイズが過剰に大きくなるのを防ぐ。例えば、巨大なリストや引数を制限する。

## タイムアウト
*	複雑なクエリを防ぐために、タイムアウトを設定して長時間実行されないようにする。
*	GraphQLでは、タイムアウトは例外ではなく通常の機能として扱われる。
*	適切な複雑性やノード制限を設定して、タイムアウト値は設定するべき。
*	複雑性やノードの上限を見つけることは難しいが、監視とデータ分析で適切な制限値を見つけることが重要。

## 認証
* 認証(Authentication)とは、ユーザが誰であるか、ログインしているかどうかを判断する行為である。
* 認可(authorization)は、ユーザーがあるアクションを実行できるかどうか、あるいはあるリソースを見ることができるかどうかを決定する行為である。
* GraphQLスキーマから認証に関する問題を除外し、クエリを実行するときにGraphQLコンテキストにcurrentUserまたはその他のセッション概念が存在することを期待するだけにすること
* リゾルバはHTTPヘッダーやトークンを意識すべきではない。こうすることで、スキーマを変更することなく、さまざまな認証スキームを入れ替えたり、サポートしたりできるし、スキーマの操作が簡単になり、よりステートレスになる。

## 認可
* 認可はGraphQLの外で処理するのがベスト
* 特にアプリ固有のビジネスロジックはGraphQLに入れないほうが良い
* APIスコープの認可（どのフィールドにアクセスできるか）ならGraphQLで管理してもOK

### フィールド単位ではなくオブジェクト単位の認可を優先すべき理由
* オブジェクト型（タイプ）はAPIスコープと相性が良い
* オブジェクト内の単純なスカラーフィールドは、通常同じ権限でアクセス可能である
* フィールド単位で認可をすると、アクセス経路の管理が非常に難しくなる

### 存在の漏洩
* APIの認可において、以下の2つの状態の区別が重要
  * 「リソースは存在するが、アクセスできない」
  * 「リソースが存在しないが、その事実を知らせない」
* セキュリティ上の懸念
  * リソースの存在自体が機密情報となる場合がある
  * エラーメッセージで「アクセスできません」と返すと、そのリソースが存在することが判明してしまう
* 推奨される対処方法
  * アクセス権のないリソースに対しては単にnullを返す
  * エラーメッセージで存在の有無を開示しない
* スキーマ設計での注意点
  * nullを返す可能性があるフィールドは、必ずnullable型として定義する必要がある
  * フィールドを非null（!）にするかどうかは、セキュリティの観点から慎重に検討する

## イントロスペクションのブロック
* 内部API（社内向けなど）の場合
  * 開発環境では有効にする
  * 本番環境では無効にしても問題ない
  * 機密情報や開発中の機能を守るため
* 公開API（一般公開）の場合
  * 基本的に制限する必要はない
  * APIの仕様は公開することが前提
  * むしろ制限すると使いづらくなる
* より良いアプローチ
  * 単純なイントロスペクションの無効化ではなくスキーマの可視性制御を使用
  * 特定の機能や情報を、特定のクライアントにのみ公開

## 永続化クエリ
* 基本概念
  * クエリを事前にサーバーに登録する仕組み
  * 実行時には完全なクエリの代わりに識別子を使用
  * サーバー側で事前に解析・検証が可能
* 主なメリット
  * 帯域幅の大幅な削減
  * サーバーリソースの効率的な利用
  * クエリの最適化が可能
  * セキュリティの向上
* 実装方法
  * デプロイ時に事前登録
  * 初回実行時に自動登録
  * 識別子として以下を使用
    * クエリハッシュ
    * URL
    * 単純なID
* セキュリティ面での利点
  * 登録済みクエリのみ実行可能
  * 不正なクエリの実行を防止
  * ホワイトリスト方式の実現が容易
* 推奨される使用場面
  * 内部API
  * 大規模アプリケーション
  * パフォーマンス重視のシステム
  * セキュリティ要件の高いシステム
* 利用可能なツール
  * Apolloのライブラリ
  * GraphQL Javaのクエリキャッシュ
  * GraphQL-Rubyのオペレーションストア
* 注意点
  * エンドポイントベースのAPIに似た形になる
  * ただし、クライアント主導でリソースを生成

## まとめ
* GraphQLのレート制限は、一般的なエンドポイントベースのAPIよりも慎重な検討が必要
* クライアントのレート制限には、複雑性ベースまたは時間ベースのアプローチが最適な選択肢
* サーバー時間を過度に消費する長時間実行クエリを避けるため、タイムアウトは必須
* クエリの深さは言われているほど重要ではなく、複雑性とノード数の制限で十分な場合が多い
* フィールド単位の認可よりも、オブジェクト型単位の認可の方がシンプルでエラーが少ない
* イントロスペクションの無効化は内部APIには有効だが、公開APIでは避けるべき
* 永続化クエリは非常に強力な概念で、特に内部APIに有効

# パフォーマンスとモニタリング
## モニタリング
* GraphQLモニタリングの特殊性
  * 従来のAPIモニタリング
    * エンドポイントごとのレスポンス時間測定
    * 単純な統計情報の収集
    * 問題の特定が比較的容易
  * GraphQLの課題
    * 単一エンドポイントで多様なクエリを処理
    * クエリの複雑さが大きく異なる
    * エンドポイントレベルの監視では不十分
* 効果的なモニタリング戦略
  * クエリレベルのモニタリング
    * 個々のクエリのパフォーマンス計測
    * クエリパターンの分析
    * 異常検知の実装
  * クライアント情報の追跡
    * クライアント識別子の使用
    * バージョン情報の収集
    * ヘッダーによる情報伝達
  * 永続化クエリとの連携
    * クエリの事前登録
    * クライアント情報の関連付け
    * パフォーマンスの追跡が容易
* 実践的なアドバイス
  * クエリの複雑さを考慮したモニタリング設計
  * クライアント情報の収集体制の整備
  * 適切なメトリクスの選定
  * 異常検知の仕組みの実装

### フィールドごとのモニタリングとトレース
* クエリのライフサイクル監視
  * パースとレキシング（構文解析と字句解析）の時間
  * バリデーションと静的解析の時間
  * 実行時間
  * 各ステップの監視が重要（実行時だけでなく）
* フィールドレベルのモニタリング
  * 個々のフィールドのパフォーマンス計測
  * 異常値の検出が容易
  * より詳細なパフォーマンス分析が可能
  * ただし収集方法によってはコストが高くなる可能性あり
* 実装方法
  * ミドルウェアの活用
  * リゾルバ拡張機能の利用
  * アプリケーションパフォーマンス管理ツールとの連携
  * カスタムトレーシングロジックの実装
* 利用可能なツール
  * GraphQL-Ruby + Prometheus
  * Apollo Server + Apollo Studio
  * OpenTracingによる分散トレーシング
  * その他のパフォーマンス管理ツール
* モニタリング戦略
  * 開発初期からの導入
  * 重要クエリの優先監視
  * 定期的なパフォーマンス分析
  * 適切なアラート設定
* トレーシングのメリット
  * クエリ実行の詳細な可視化
  * 問題箇所の特定が容易
  * マイクロサービス環境での追跡が可能
  * パフォーマンス最適化の指針となる
* 注意点
  * モニタリングコストとのバランス
  * 適切なログレベルの設定
  * データ収集量の管理
  * セキュリティ考慮（機密情報の扱い）
* 期待される効果
  * パフォーマンスボトルネックの早期発見
  * システム全体の最適化
  * ユーザー体験の向上
  * 運用コストの削減

### GraphQLレスポンス拡張機能
* 基本概念
  * レスポンスに`extensions`キーを使用してメタデータを追加可能
  * パフォーマンス情報やデバッグ情報を含められる
  * Apollo Tracingは一般的な実装例だが、独自フォーマットも可能
* トレース情報の主要項目
  * 全体の実行時間（startTime, endTime, duration）
  * パース処理の情報（parsing）
  * バリデーションの情報（validation）
  * 各リゾルバの実行情報（resolvers）
  * 外部呼び出しの実行時間
* パフォーマンス監視のポイント
  * リゾルバ自体のCPU処理時間
  * 外部サービスへの呼び出し時間
    * データベースクエリ
    * キャッシュアクセス
    * 外部APIコール
  * ボトルネックの特定と最適化
* 使用上の注意点
  * 全てのレスポンスに含めることは非推奨
  * レスポンスサイズへの影響を考慮
  * 必ず圧縮を使用すべき
  * 公開APIでの使用は慎重に検討
* 実装時の推奨事項
  * 環境ごとの適切な設定
    * 開発環境：詳細なトレース情報
    * 本番環境：選択的な有効化
  * セキュリティ考慮
    * 機密情報の漏洩防止
    * アクセス制御の実装
  * パフォーマンス最適化
    * 必要な情報のみを含める
    * 効率的なデータ収集方法の選択
* 活用のメリット
  * パフォーマンス問題の早期発見
  * ボトルネックの正確な特定
  * システム全体の最適化
  * デバッグの効率化
  * 運用監視の向上
* 実装時のベストプラクティス
  * モジュール化されたトレーシング実装
  * 適切なログレベルの設定
  * 効率的なデータ収集
  * 柔軟な拡張性の確保
  * 監視システムとの連携
* 運用上の考慮点
  * データ量の管理
  * ストレージコストの考慮
  * パフォーマンスへの影響監視
  * 定期的な分析と最適化
  * アラート設定の適切な調整

### スロークエリログ
* 基本概念
  * データベース実装から派生した考え方
  * クエリの実行時間に閾値を設定
  * 閾値を超えたクエリを自動的にログ記録
* 有用なケース
  * 既知のクエリセットの管理
  * パブリックAPIの運用
  * 大規模なクライアント・クエリセットの管理
* メリット
  * 高コストクエリの早期発見
  * 問題の予防的な検出
  * シンプルで効果的な監視手法
* 活用方法
  * パフォーマンス監視の基本ツールとして
  * システム最適化の指標として
  * 予防的なメンテナンスの判断材料として

### クエリの経時的追跡
* パフォーマンス監視の目的
  * 性能低下（リグレッション）の検出が主な関心事
  * 時間単位での比較（1時間、1日、1週間など）
  * 継続的な性能変化の追跡
* 追跡方法
  * 時系列データベースの活用
  * データウェアハウスの利用
  * Apollo Platformなどの既存ツールの活用
* クエリの正規化
  * クエリ文字列の変動要因
    * 空白の有無
    * 引数の違い
    * フィールドの順序
  * ハッシュ/署名の計算による正規化
* GitHubの実装例
  * クエリ文字列のハッシュ化
  * 変数も含めたハッシュ計算
  * クエリと変数のペアでの追跡
* メリット
  * 正確なパフォーマンス比較が可能
  * データ量による影響の正確な把握
  * より効果的なリグレッション検出
* 解決される課題
  * クエリの複雑さの違いを考慮
  * データ量の違いによる影響を考慮
  * より正確な性能比較が可能

## GraphQLのリゾルバパターンとN+1問題の要点
### DataLoaderと遅延ロード
* 基本概念
  * 「先読み」とは逆の発想を採用
  * データロードを意図的に遅延させる戦略
  * 非同期アプローチを基本とする
* リゾルバの動作
  * 即時の値返却ではなく「不完全な結果」（Promise）を返す
  * 深さ優先探索ではなく、同レベルのリゾルバを優先
  * データフェッチを即時実行せず、実行エンジンに予告
* ローダーの特徴
  * データストアへの直接アクセスを避ける
  * 識別子を収集してバッチ処理を実現
  * 効率的なデータロードを実現
* ローダーの主要メソッド
  * `#load`メソッド
    * ロードキーを引数として受け取る
    * Promiseを返却
    * リゾルバ内で使用
  * `#perform`メソッド
    * 蓄積されたキーを一括処理
    * 効率的なデータロード実行
    * 開発者定義またはバッチ関数呼び出し
* 実装の違い
  * **Node.js**
    * `process.nextTick`でバッチロード
    * キューシステムによるPromise管理
    * バッチ処理の実行タイミング制御
  * **GraphQL-Ruby**
    * 専用の遅延実行エンジン
    * レベルごとのリゾルバ関数解決
    * Promise解決のタイミング制御

### 遅延ロードの欠点
遅延ロードはGraphQLサーバーのパフォーマンスにおいて非常に重要な要素であるが、以下の欠点が存在する
* モニタリングの複雑化
  * モニタリングがより困難になる
  * 実行は個々のリゾルバのタイミングだけの問題ではなくなる
* デバッグの困難さ
  * 実行の概念モデルが以前ほど明確ではなくなる
  * パフォーマンスの問題をデバッグすることが困難である
* パフォーマンス計測の不正確さ
  * 個々のフィールドのパフォーマンスが実態を反映しない場合がある
  * 例：数千人のユーザーのロードをキューに入れるだけのフィールドの場合
    - フィールドのパフォーマンス監視では高速に解決されているように見える
    - 実際の処理はローダーに委ねられており、別途監視が必要である
* 非同期処理の課題
  * すべての処理が非同期となる
  * JavaScript等の非同期処理に慣れた言語では問題は少ない
  * プロミス/フューチャーのサポートが不十分な言語では扱いが困難である

## キャッシング
* よくある誤解
  * 「GraphQLはキャッシュを破壊する」
  * 「GraphQLはキャッシュできない」
  * これらは適切なニュアンスを欠いた主張である
* 議論の現状
  * 多くの企業がキャッシングに関する明確な答えがないまま導入を検討
  * キャッシングに関する懸念が導入の障壁となっている
* 議論に必要な視点
  * キャッシングの種類の明確化が必要
    - クライアントサイドキャッシュ
    - サーバーサイドキャッシュ
    - HTTPキャッシング
    - アプリケーション側のキャッシュ
* 適切な理解のために
  * キャッシングの文脈を正確に理解する必要性
  * GraphQLのキャッシングの限界を適切に把握することの重要性
  * 各キャッシング手法の特徴と制約の理解が必要

### HTTPキャッシュ
* キャッシュエンティティの種類
  * クライアント側キャッシュ
    * ブラウザキャッシュが代表例
    * 新鮮なデータの再取得を防止
  * ゲートウェイキャッシュ
    * サーバーと共に配備
    * 不要なサーバーアクセスを防止
* 重要な2つの概念
  * フレッシュネス
    * Cache-ControlとExpiresヘッダーを使用
    * リソースの鮮度期間を指定
    * 例：`Cache-Control: max-age=3600`
    * 静的アセットに特に有効
  * バリデーション
    * データの再取得を避けるための仕組み
    * 主な手法：
      - Last-Modified / If-Modified-Since
      - ETag（リソースのバージョン管理）
* 特徴と利点
  * フレッシュネスとバリデーションの組み合わせで効果的な制御が可能
  * ブラウザアセットなど変更頻度の低いデータに最適
  * クライアントとゲートウェイの両方でキャッシュ制御が可能

### GraphQLとHTTPキャッシング
* GraphQLとHTTPキャッシングの基本的な課題
  * HTTPキャッシングに関連する問題が主要
  * サーバーサイドキャッシングには複数の形態が存在
    - HTTPゲートウェイキャッシュ
    - アプリケーションサイドキャッシング
* HTTPメソッドの影響
  * POSTメソッドに関する誤解の存在
  * POSTリクエストはキャッシュ不可
  * GETメソッドでのGraphQLクエリは有効かつキャッシュ可能
* 永続化クエリの利点
  * クエリ文字列のサイズ制限問題を解決
  * サーバー側でクエリを保存
  * 通常のHTTPエンドポイントとして機能
  * 例：`GET /graphql/my_query`
* キャッシュの課題
  * HTTPセマンティクスはレスポンス全体に対して動作
  * フィールドごとの個別制御が不可能
  * クエリ全体に対するmax-age設定が必要
  * 単一フィールドの無効化がクエリ全体を無効化
* カスタマイズ性とトレードオフ
  * エンドポイントの例：
    - 基本：`GET /user/1`
    - カスタマイズ可能：`GET /user/1?partial=complete`
    - フィールド指定：`GET /user/1?fields=name,friends`
* キャッシュの希釈化
  * カスタマイズ性の向上によりキャッシュ効率が低下
  * フィールドの変更がキャッシュ全体に影響
  * サブセット/スーパーセットの問題
* 結論
  * 「GraphQLはキャッシュ不可能」は誤り
  * より正確な表現：「高度にカスタマイズ可能なAPIはHTTPキャッシュの恩恵を受けにくい」
  * カスタマイズ性と効率的なキャッシングはトレードオフの関係

### HTTPキャッシュとGraphQL
* HTTPキャッシュの基本特性
  * 頻繁に変更されないデータに効果的
  * ゲートウェイキャッシュは複数ユーザーで共有可能
  * 認証されたウェブAPIでの有用性は議論の的
* 認証とキャッシュの関係
  * 共有キャッシュはAuthorizationヘッダー付きリクエストをキャッシュすべきでない
  * プライベートキャッシュ（ブラウザ/クライアントサイド）は利益を得られる
  * GraphQLのキャッシュ効率は一律のAPIより低い
* キャッシュの実践的な制約
  * 多くのウェブAPIは長期的な古いデータ保持が困難
  * バリデータ（ETag/Last-Modified）の計算にはビジネスロジック実行が必要
  * 主なメリットはシリアライゼーションと帯域幅の節約
* GraphQLの特性と課題
  * 認証APIやリアルタイムデータに適している
  * HTTPキャッシングは有益だが、仕様の不在が課題
  * GETメソッドでのミューテーション実行などの問題が存在
* キャッシュの多層的アプローチ
  * クライアントレベル
  * レスポンス全体レベル
  * 個々のリゾルバレベル
* 今後の展望
  * Apolloなどのベンダーがキャッシュセマンティクスの組み込みを検討
  * GraphQL特化のアプローチが主流
  * GraphQLセマンティクスの理解に基づく発展の可能性
* 選択の指針
  * ユースケースに応じた適切なAPI設計の選択が重要
  * 認証やリアルタイムデータの要件を考慮
  * HTTPの効果的な使用が可能なアーキテクチャの検討

###キャッシング実際
* 基本概念
  * GraphQLのキャッシュは複雑だが価値がある
  * パブリックAPIと比べて効果は低いものの重要
  * アプリケーションレベルでの実装が効果的
* Shopifyのアプローチ
  * キャッシュ可能な型を明示的に定義
  * `@cacheable`アノテーションの使用
  * 例：商品、バリアント、画像など
  ```graphql
  type Product @cacheable {
    name: String
  }
  ```
* キャッシュの動作
  * サーバーがフィールドのキャッシュ可能性を確認
  * 全てのタイプがキャッシュ可能な場合のみキャッシュを実行
  * 1つでもキャッシュ不可能なフィールドがあると無効化
* キャッシュキーの重要要素
  * ユーザー情報（認証API用）
  * 正規化されたクエリーハッシュ
  * 変数ハッシュ
  * オペレーション名
  * キャッシュ破壊要素
* キャッシュキー生成の注意点
  * ユーザーIDやクライアント識別子の適切な使用
  * クエリー文字列の正規化（空白・コメントの除去）
  * フィールド順序の考慮
  * 変数の適切な処理
* 運用上の考慮事項
  * 複数オペレーションの適切な処理
  * キャッシュの有効期限（TTL）の設定
  * バージョン管理の実装
  * データの鮮度の維持
* 実装のベストプラクティス
  * キャッシュ可能な型の明確な定義
  * 適切なキャッシュキーの設計
  * バージョニングの導入
  * TTLの適切な設定

### データレイヤーのキャッシング
* バッチローダーの二重の利点
  * データベースクエリの効率化
  * 重複クエリのキャッシング機能
* 実装のメリット
  * シンプルな実装
  * 効果が高い
  * 動的クエリよりも管理が容易
* 推奨アプローチ
  * データレイヤーのキャッシングを最優先
  * 段階的に高度なキャッシングを導入

### リゾルバーキャッシング
* 基本的な課題
  * GraphQLクエリの動的性質によりフルレスポンスキャッシングが困難
  * 個別フィールドのリゾルバキャッシュが代替案として検討される
* キャッシング実装の考慮点
  * フィールド名
  * 引数名
  * コンテキスト引数の扱い
* コンテキストに関する注意点
  * 多くの実装でコンテキスト引数の考慮が漏れやすい
  * コンテキストから生成される可能性のある全データの考慮が必要
  * 汎用的なキャッシュソリューション導入時の複雑さ
* 推奨アプローチ
  * システム内の他のロジックと同様に個別に検討
  * 高コストな処理を含むリゾルバを優先的に検討
  * 問題のあるフィールドロジックに焦点を当てる

## まとめ
* GraphQLは、一般的なエンドポイントベースのAPIに比べて、本質的に最適化が難しい。
* GraphQLを監視するには、エンドポイントの応答時間を監視するのではなく、個々のフィールドやクエリーを監視する必要があることがよくある。
* N+1問題はレイジーローディングで回避できる。
* キャッシュはGraphQLでも可能だが、他のAPIスタイルほど強力ではないことが多い。

# ツール
## リンティングツール
* コードの一貫性を保つための重要な役割
* スキーマ規模拡大時の品質維持に不可欠
* 大規模開発チームでの一貫性確保に貢献
* ゲートキーピングの自動化を実現
* 実装例
  * GraphQL Doctor（GitHub内部ツール）
    * 300人以上のエンジニアが貢献するスキーマの品質確保
    * プルリクエストボットとして機能
    * ベストプラクティスの推奨を自動化
  * graphql-schema-linter
    * JavaScript向けオープンソースツール
    * GraphQLスキーマの検証に特化

## 変更管理ツール
* 潜在的に危険な変更の検出
* スキーマバージョン比較機能
* インテグレーションの破壊防止
* 主要な変更管理ツール
  * GraphQL Schema Comparator
    * 著者自身が開発
    * GraphQL Doctorの内部で使用
  * GraphQL-JSのスキーマコンパレータ
    * コア実装に含まれる機能
  * Sangriaのスキーマコンパレータ
    * Scala実装におけるツール
  * Apollo Platform
    * 変更検出の自動化
* ツールの主な利点
  * 破壊的変更と非破壊的変更の分類
  * クライアントへの影響評価
  * 大規模チームでの手動監視の限界を克服

## アナリティクス
* GraphQLの分析的特徴
  * クエリで要求されるフィールドの追跡が可能
  * APIの使用状況を詳細に把握できる強力な機能
  * 非推奨フィールドの特定と影響評価が容易
* RESTful APIとの比較
  * RESTではリソースアクセスのみ把握可能
  * GraphQLでは特定のフィールド使用状況まで追跡可能
* 分析実装手法（GitHubの例）
  * すべてのリクエストの収集とスキーマとの照合
  * クエリ実行プロセス外での分析処理
  * クライアントのクエリ時間への影響を回避
* 収集すべき情報
  * アクセストークン、ユーザー情報、アプリケーション情報
  * GraphQLエラー（パースエラー、不在フィールドなど）
  * リゾルバのタイミング、クエリ実行時間などのパフォーマンス指標
* 技術的実装のポイント
  * スキーマバージョン情報の送信（ハッシュ値など）
  * スキーマSDLの効率的な取得方法
  * クエリの非正規化によるエンティティセットへの変換
* データ収集の詳細
  * フィールドリスト（親タイプ付き）
  * 使用された引数のリスト（親フィールドと型付き）
  * フラグメントスプレッドの使用状況
  * 列挙値の使用状況
* 分析活用例
  * 特定フィールドを使用するトップインテグレーターの特定
  * 関連性の高いフィールドの発見
  * パフォーマンス問題の特定
  * 非推奨フィールドの使用状況確認
  * 引数の安全な削除判断
  * APIの使用パターン把握とデバッグ

### 敏感なパラメータの削除
* 基本的な考え方
  * クエリの保存・分析前の機密データ削除が重要
  * 通常のHTTPパラメータと異なりクエリ文字列内を調査する必要あり
  * クエリの有効性を保ちながらデータを匿名化するアプローチが有効
* 実装方法
  * ユーザー提供データをプレースホルダーに置換
  * NULL許容フィールドの場合はNULLに変更
  * クエリの構造を維持して分析可能な状態を保つ
* 重要な注意点
  * リスト型パラメータのサニタイズ
  * 入力型パラメータのサニタイズ
  * スキーマに対して有効なクエリ構造の維持
* 実装の利点
  * 使用された引数やフィールドの分析が可能
  * ユーザー提供値の機密性を保護
  * 分析データの安全な保存と活用
* 実装の課題
  * アナライザ構築は容易ではない
  * システムアーキテクチャに大きく依存
  * 自動化ツールが比較的少ない
* ツールの選択肢
  * Apolloが提供するツールが有用

# ワークフロー
* APIの品質維持が困難になる
* 一貫したプロセス管理が必要
* チーム特性に合わせたワークフロー開発が重要

## デザイン
* デザインの重要性
  * 慎重な設計がAPI品質を長期的に保証
  * 多くのチームが実装に早く移行しすぎる傾向
  * 事前設計と議論により将来の問題を回避可能
* 効果的なデザインアプローチ
  * GitHubイシューなどでSDLを用いた初期設計の共有
  * 早期段階からの多職種参加（PM、デザイナー、ドキュメント担当者）
  * 実装前の設計レビューの実施

## レビュー
* レビューのポイント
  * 設計の意味と一貫性の確認が目的
  * リンターで自動化できない核心部分に集中すべき
  * 組織の成長に合わせたレビュー体制の進化が必要
* レビュアーの選定と課題
  * 組織拡大に伴い「GraphQL専門家」だけでは不足
  * レビューチームは初期段階では有効だが拡張性に難あり
  * レビュー時間増加はツール投資の必要性を示すサイン

## 開発
* 質の高いツールと優れたスキーマ定義APIの構築
* 「間違ったことをするのが難しい」環境の整備
* チーム環境整備の要点
  * GraphQLと優れたAPI設計のドキュメント提供
  * ベストプラクティスに自然に導くAPIとツール
* 開発フェーズの取り組み
  * 設計合意後の実装開始が理想的
  * 実装詳細が設計に影響しないよう注意
  * 本書の一般的アドバイスに従う

## 公開
* 公開フェーズの基本
  * 設計・実装・品質確認後の次のステップ
  * 単一クライアントの場合は比較的シンプル
  * 複数クライアントや公開APIでは詳細な計画が必要

### モックサーバーの活用
* GraphQLインターフェースに準拠した疑似環境
* 実データに影響を与えずに設計検証が可能
* GraphQLの型システムにより簡単に構築可能
* 主要ツール：
  - Apolloの`graphql-tools`
  - GraphQL-Faker（CLIベース）
* CIへの統合で効率化が可能

### フィーチャーフラグの利用
* 実環境で特定クライアントに機能を限定公開
* スキーマの可視化技術と組み合わせて実装
* 社内クライアントから始め徐々に拡大
* 特定パートナーと直接コミュニケーションが可能
* 既存スキーマより新機能に対して実装が容易

### APIプレビュー
* 誰でも利用できる公開テスト環境
* 特別なヘッダーで参加可能な方式
* 大量の未知クライアントからフィードバック収集に有効
* 実装例：
  - HTTPヘッダーによる制御（例：`FooCorp-API-Preview: new-cool-feature`）
  - スキーマ可視性フィルターと連携
* プレビュー利用の注意点
  * 過剰利用に注意
  * 長期間のプレビュー状態を避ける
  * フィードバック収集後は迅速に正式版へ移行
  * 内部API/パートナーAPIではフィーチャーフラグが推奨
* 選択基準
  * 公開APIではプレビューが有用
  * 内部/パートナーAPIではフィーチャーフラグが適切
  * 用途に応じた適切な手法の選択が重要

## 分析
* 公開後も継続的な観察が必要
* スキーマ分析ツールによる使用状況の追跡
* 時間経過に伴う利用パターンの変化を監視
* 主要な分析ポイント
  * 新機能のパフォーマンス評価
  * 利用率の測定
  * 主要ユーザーからのフィードバック収集
* GraphQLの分析上の利点
  * 宣言的な性質により詳細な分析が容易
  * インテグレーターの回避策から新機能のヒントを発見可能
  * APIユーザーとの直接コミュニケーションの価値

## 本格的な公開
* 条件
  * 実際のユースケースに基づいた設計
  * ステークホルダー・ドメインエキスパートの参加
  * コードレビューと自動リンターによる品質保証
  * 限定公開による機能検証とリスク最小化
  * 使用状況のモニタリングと分析の実施
* 継続的なフォローアップ
  * パフォーマンスの継続監視
  * 使用状況の継続分析
  * 新規クライアント統合からの学習

# バージョニング
* どのバージョニング手法も完璧ではない
* サーバー側・クライアント側双方に課題をもたらす可能性がある
* GraphQLは継続的な進化に適した機能を持つ
* 従来型のバージョニングも可能
* どの手法でもミスは発生しうる
* コミュニケーションが最も重要
* 変更の適用プロセスの透明性を確保する

## ベストプラクティス
* 常に追加的・後方互換性のある変更を優先する
* `deprecation`ディレクティブを積極的に活用する
* `reason`引数を自社ツールやベストプラクティスで強化する
