# スキーマ設計
## Naming
* 命名の一貫性が重要
* クライアントが予測可能な名称にする
* 使用する名詞や動詞に一貫性を持たせるべき
* できるだけ具体的にしてクライアントの混乱を避ける
  * 「User」や「Event」のような一般的または汎用的な名前は良くない

## Descriptions
* スキーマがよく設計されていれば、descriptionsはほとんど不要のはず
* ユーザーのユースケースに対する理解をdescriptionsに依存させないことが重要

## スキーマを使いやすく・理解しやすくする方法
* 可能な限りフィールドは1つのことに特化する。
* スキーマが強制できる場合は、サーバーサイド実行時ロジック（バリデーションや変換）を避ける。
  * enumを利用して許容する状態を明確にする
  * nullが許容できない場合は!をつける
* デフォルト値を使用して、オプションの入力や引数を使用する際のデフォルトの動作を示す。

## ページネーション
* オフセット
  * 「何件目から何件取得するか」を指定する方法
  * データの更新でページ間の整合性が崩れる可能性有

* カーソル（通常はこちらで実装すべき）
  * 各アイテムに一意の識別子（カーソル）を付与し、そのカーソル以降のデータを取得する方法
  * データが変動してもズレが生じない

## 「nullを許容するかどうか」を決める際のガイドライン
* 引数について
  * 基本的に、引数は必ず値が渡されるように（non-null）すると、APIが予測しやすくなり、使いやすくなる
  * ただし、新しく引数を追加する場合は、既存のクライアントを壊さないようにnullableにするのがベスト
* データ取得に失敗する可能性があるフィールド
  * データベースの関連付けやネットワーク呼び出しなど、将来エラーが起こりうるフィールドは、失敗時にnullを返せるようにnullableにしておくと安全
* すでに親オブジェクトでロード済みのシンプルなスカラー値
  * 実行時にすでに値が存在することが保証されているため、non-nullにしても問題ない

## Abstract Types
### インターフェース
* 振る舞いを共有するものに対して共通の仕様（ルール）を提供するものであるべき
* 複数の型がいくつかのフィールドを共有しているが、これらの型が共通の振る舞いを共有していない場合、単にインターフェイスを混在させる誘惑を避けるべき
* 強い意味を持たないインターフェースの命名はぎこちなくなる

### ユニオン
あるフィールドが異なる型を返す可能性があるが、それらの型が必ずしも共通の振る舞いを持つとは限らない場合に使用する

## 静的クエリの設計
GraphQLでは、クエリを直接文字列として記述する「静的クエリ（static query）」の設計が推奨されている。
なぜ静的クエリが良いのか？

* コードの可読性が向上する
  * 静的クエリなら、ソースコードを見ただけでどのフィールドが必要なのか、どのような形のデータが返ってくるのかが一目瞭然
* ツールの恩恵を受けられる
  * 静的なクエリは、IDEによる補完やエラーチェック、コード生成ツールとの連携が容易になる
* サーバーとの契約が明確になる
  * 静的クエリは変更されないため、デプロイ前にどのクエリが送信されるかを正確に把握でき、クライアントとサーバー間の契約が明確になる
* ログや解析が容易になる
  * クエリに名前を付けておくと、サーバー側でのログ収集や、どのクエリが頻繁に使われているかの解析がシンプルになる

## Mutation
### Relayの慣習
各Mutationに対して「ひとつの必須の入力型（input type）」を使うことが推奨される。

**メリット**
* 進化しやすい（Evolvability）
  * ひとつのinput型にまとめることで、後からフィールドを追加・変更する際、Mutation自体のシグネチャを大きく変える必要がなくなる。
* クライアント側が使いやすい
  * 複数の引数を個別に渡すのではなく、ひとつの変数（inputオブジェクト）で済むため、クライアント側のコードがシンプルになる。
* APIの一貫性
  * 同じパターンを使うことで、API全体での統一感が生まれ、他のAPIと合わせて理解しやすくなる。

## エラー
### エラーに含まれる情報
* message: エラーの内容を説明する文字列
* locations: クエリ内のエラー発生箇所（行や列）
* path: どのフィールドでエラーが起きたかを示すパス
* extensions: エラーコードなど追加情報を入れるためのフィールド

### エラーの種類
* 開発者／クライアントエラー
  * ネットワークのタイムアウト、IDの形式が正しくない、レート制限など、クライアント側が対処するべきエラー等
  * これらはGraphQLのerrorsフィールドに含まれ、開発者がデバッグやロギングに利用する。
* ユーザーエラー
  * 例えば、「メールアドレスが既に使われています」や「チェックアウトを二重に行おうとした」など、ビジネスルールに基づくエラー
  * これらはエラーとしてレスポンスのerrorsに入れると、Mutation全体がnullになってしまい、クライアントにデータが返せなくなる
  * そのため、**ユーザーエラーはGraphQLスキーマの一部として、Mutationのペイロードにエラー情報を含める設計が推奨される。**

## スキーマ編成
### Mutation
* 突然変異の名前には、以下のような具体的で読みやすい名前を使うことを恐れないでほしい。
* cartProductAddのようなものではなく、addProductsToCartです。

### データ駆動型スキーマ vs ユースケース駆動型スキーマ

**データ駆動型スキーマ**

データそのものに焦点を当てて設計されたスキーマ。
クライアントが必要な情報だけを素早く取得するために作られます。
例えば、「全てのコメントを取得する」など、特定のデータを大量に取得するユースケースです。

**ユースケース駆動型スキーマ**

使いたい機能に焦点を当てて設計されたスキーマ。
ユーザーが特定のアクションを実行するために設計されたもの。
例えば、「GitHubで問題を開く」「プルリクエストをマージする」といったビジネスロジックに関連する機能です。

**GraphQL でのデータ駆動型ユースケースの課題**
* ページネーション
  * データを大量に取得したい場合、ページネーション（データを分割して送る）が邪魔になることがある。
  * 例えば、クライアントが全てのコメントを一度に取り出したい場合、ページネーションにより取得が分割され、効率が悪くなる。
* タイムアウトと制限
  * 大きなリクエストを送ると、サーバーがタイムアウトでリクエストを切断したり、レート制限がかかってしまう可能性が高い。
  * 大量のデータを取得しようとするデータ駆動型クライアントは、これらの制限により困難を伴う。

## Summary
GraphQLスキーマを設計する際に特に重要な4つのポイントは下記のとおり
1. デザインファーストのアプローチを採用する
    * スキーマの開発では、まず設計を重視。ドメイン知識を持つチームメンバーと議論し、実装の細かい部分は後回しにする。
2. クライアントのユースケースを基準に設計する
    * データ構造や型、フィールド単位で考えるのではなく、クライアントがどのようにAPIを使うかを意識して設計する。
3. スキーマをできるだけ表現力豊かにする
    * スキーマ自体がクライアントにとって「正しい使い方」を示すように設計する。ドキュメントは補足的な役割として考えるべき。
4. 汎用的すぎるスキーマを避ける
    * 「賢い」設計にこだわらず、特定のユースケースに適した明確なフィールドや型を作ることが大切。

#  GraphQLサーバーの実装
## スキーマの構築
できるだけコードファーストでスキーマを構築することがおすすめ

## リゾルバーデザイン
* シンプルであるべき
  * いいリゾルバーは少ないコードで書かれ、主にユーザーからの入力を処理し、ドメイン層（アプリケーションのビジネスロジック）にアクセスして、結果をAPIに返す形になる。
* ビジネスロジックを分ける
  * GraphQLリゾルバーが全てのロジックを処理するのではなく、ドメイン層にビジネスロジックを集中させることが重要。
  * リゾルバーはあくまで「インターフェース」として機能すべきで、ビジネスロジックを直接扱うべきではない。
* 一貫性の維持
  * GraphQL APIは、アプリケーション内の唯一のインターフェースではないことが多い。たとえば、同じビジネスロジックがUIやREST API、マイクロサービス間でも使われているかもしれない。
  * すべてが一貫性を保つためには、ロジックを複数の場所で管理しない方が良い。GraphQLのリゾルバーでロジックを大量に処理しない方が、システム全体の整合性を保てる。

### コンテキストオブジェクトに注意
* GraphQLの「コンテキストオブジェクト」は、リクエストの情報を保存するために非常に便利。例えば、リクエストのIPアドレスや認証情報を保存するのに使う。
* ただ、コンテキストに依存しすぎると、APIが予測できなくなったり、テストが難しくなったりする。
* コンテキストをクエリ実行中に変更することも避けるべき。コンテキストに新しい情報を追加すると、リゾルバーの順番に依存してしまい、システムが複雑になって予期しない動作を引き起こすことがあある。
* コンテキストの中身を厳選するべき。また、クエリを実行する前に、コンテキストの特定の部分を必須にするのも良いアイデアかもしれない。

### Summary
優れたリゾルバーを書くには
* GraphQLレイヤーからビジネスロジックをできるだけ排除する。
* コンテキストの引数はできるだけ不変にしておくこと。
* フィールドが特定の順序で呼び出されることに依存したり、コンテ
キストの特定の値が他のフィールドによって入力されたと思い込ん
だりしない。

## テスト
テストをしやすくする最も重要なポイントは「リゾルバの設計をシンプルにすること」

### 統合テスト
* フィールドの取得テスト
* 全てのフィールドを含むクエリのテスト
* 認可のテスト

### リゾルバーの単体テストで注意すべき事項
* GraphQL の型変換（Type Coercion）
* ミドルウェアやプラグインの影響
* context オブジェクトの扱い
* parent オブジェクトのモック

## Summary
GraphQLサーバー実装の基本的な原則
*	拡張性の高いコードファースト（Code-First）フレームワークを優先する
    *	メタデータ、プラグイン、ミドルウェアの追加が容易なフレームワークを選ぶことで、柔軟な開発が可能になる。
*	GraphQLレイヤーは可能な限り薄く保ち、ビジネスロジックは独自のドメインレイヤーに移す
    *	GraphQLはあくまでAPIのインターフェースであり、ビジネスロジックをリゾルバに埋め込むのではなく、独立したドメインレイヤーに分離する。
*	リゾルバをできるだけシンプルにし、グローバルな可変状態に依存しない
    *	ステートレスな設計を心がけることで、デバッグやテストが容易になる。
*	モジュール化は必要になった時点で行う。特定のフレームワークにこだわらず、プログラミング言語の特性を活用する
    *	無理に早い段階で分割せず、コードが複雑になり始めたら適切なモジュール化を行う。
*	ドメインロジックのほとんどはドメインレイヤーでテストする。GraphQLサーバーのテストでは統合テストが最もコストパフォーマンスが高い
    *	単体テストではなく、GraphQLのクエリ全体をテストする統合テストを重視する。
*	実行時の条件によってスキーマを少し変える場合は可視性フィルター（Visibility Filters）を使う。ただし、大きく異なるスキーマが必要な場合は、ビルド時に別のサーバーを構築することも検討する
    *	例えば、認可によって特定のフィールドを非表示にする場合は可視性フィルターを活用し、まったく異なるAPIが必要なら独立したGraphQLサーバーを作る。

# セキュリティ
## レート制限
GraphQL APIが効果的にクライアントをレート制限するためのテクニックは下記のとおり
### 複雑性ベースのアプローチ
* 複雑性（コスト）の計算
    * クエリごとにコストを計算し、リクエスト数だけでなく、サーバー負荷に基づいてレートリミットを設定する。
* オブジェクト単位でコストを計算
    * スカラーフィールドは軽いため、オブジェクト（ノード）単位で計算する方が良い。
* ページネーションを活用
    * リスト型データはページネーションを使用し、クエリのコストを予測しやすくする。これにより、大量データの取得を制限できる。
* 動的 vs 静的なレートリミット
    * 動的なコスト計算は不安定になりがちなので、静的なコスト設定（固定値）が推奨される。
* 高コストなクエリの事前拒否
    * クエリ実行前にコストを計算し、過度に負荷の高いクエリを実行する前に拒否する。
* ツールの活用
    * GraphQL RubyのAnalyzer API や、JavaScriptの graphql-query-complexity などのツールを使用して、クエリの複雑性を解析する。

### 時間ベースのアプローチ
クエリの実行時間を基にサーバーの負荷を評価する方法。この方法はサーバーコストをより正確に反映し、通常ミドルウェアで実装され、リクエストからレスポンスまでのミリ秒数を計測します。

* 利点
	*	サーバーコストの正確な評価ができる。
	*	実行時間に基づくため、シンプルに実装可能。

* 問題点
	* サーバー応答時間が変動するため、同じクエリでも遅い時間帯にはレート制限される可能性がある。
	* クライアントは実行時間を予測できず、デプロイ後に調整が必要で予測が難しい。

### レートリミットの公開
* 目的
  * クライアントが自身のリクエストがレートリミット内か、制限を超える前にどれくらい残っているかを知るために、APIレスポンスにレートリミットの情報を提供する。
* 方法
  * 一般的にはレスポンスヘッダーで提供され、例えばGitHubのAPIでは、リクエスト制限、残りリクエスト数、リセット時間などを通知。
* GraphQLでの実装
  * GitHubのGraphQL APIではrateLimitフィールドを使い、クエリ実行時にそのコストや制限情報を取得可能。dryRun引数を使えば、実際にデータを取得せずに計算結果だけを確認できる。
* 注意点
  * クライアントがレートリミットを回避しようとする可能性があり、システムが正確に情報を提供するのが難しい場合もある。そのため、クライアントには適切に対応できるよう教育が必要。

## 悪意のあるクエリのブロック
GraphQLのクエリがサーバーに過剰な負荷をかけないようにするために、以下の制限方法がある
* 深さ制限（Depth Limit）
  * クエリが過度に深くネストされるのを防ぐ。例えば、クエリの最大深さを制限して、サーバー負荷を軽減する。
* 幅制限（Breadth Limit）
  * 同じリソースを複数回リクエストすることを防ぐ。複数のリソースを一度にリクエストする場合に制限を設ける。
* ノード制限（Node Limit）
  * クエリ内で要求されるオブジェクト数を制限し、過剰なリソース要求を防ぐ。
* バイトサイズ制限（Byte Size Limit）
  * クエリや変数のサイズが過剰に大きくなるのを防ぐ。例えば、巨大なリストや引数を制限する。

## タイムアウト
*	複雑なクエリを防ぐために、タイムアウトを設定して長時間実行されないようにする。
*	GraphQLでは、タイムアウトは例外ではなく通常の機能として扱われる。
*	適切な複雑性やノード制限を設定して、タイムアウト値は設定するべき。
*	複雑性やノードの上限を見つけることは難しいが、監視とデータ分析で適切な制限値を見つけることが重要。

p82 p145
