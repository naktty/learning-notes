# スキーマ設計
## Naming
* 命名の一貫性が重要
* クライアントが予測可能な名称にする
* 使用する名詞や動詞に一貫性を持たせるべき
* できるだけ具体的にしてクライアントの混乱を避ける
  * 「User」や「Event」のような一般的または汎用的な名前は良くない

## Descriptions
* スキーマがよく設計されていれば、descriptionsはほとんど不要のはず
* ユーザーのユースケースに対する理解をdescriptionsに依存させないことが重要

## スキーマを使いやすく・理解しやすくする方法
* 可能な限りフィールドは1つのことに特化する。
* スキーマが強制できる場合は、サーバーサイド実行時ロジック（バリデーションや変換）を避ける。
  * enumを利用して許容する状態を明確にする
  * nullが許容できない場合は!をつける
* デフォルト値を使用して、オプションの入力や引数を使用する際のデフォルトの動作を示す。

## ページネーション
* オフセット
  * 「何件目から何件取得するか」を指定する方法
  * データの更新でページ間の整合性が崩れる可能性有

* カーソル（通常はこちらで実装すべき）
  * 各アイテムに一意の識別子（カーソル）を付与し、そのカーソル以降のデータを取得する方法
  * データが変動してもズレが生じない

## 「nullを許容するかどうか」を決める際のガイドライン
* 引数について
  * 基本的に、引数は必ず値が渡されるように（non-null）すると、APIが予測しやすくなり、使いやすくなる
  * ただし、新しく引数を追加する場合は、既存のクライアントを壊さないようにnullableにするのがベスト
* データ取得に失敗する可能性があるフィールド
  * データベースの関連付けやネットワーク呼び出しなど、将来エラーが起こりうるフィールドは、失敗時にnullを返せるようにnullableにしておくと安全
* すでに親オブジェクトでロード済みのシンプルなスカラー値
  * 実行時にすでに値が存在することが保証されているため、non-nullにしても問題ない

## Abstract Types
### インターフェース
* 振る舞いを共有するものに対して共通の仕様（ルール）を提供するものであるべき
* 複数の型がいくつかのフィールドを共有しているが、これらの型が共通の振る舞いを共有していない場合、単にインターフェイスを混在させる誘惑を避けるべき
* 強い意味を持たないインターフェースの命名はぎこちなくなる

### ユニオン
あるフィールドが異なる型を返す可能性があるが、それらの型が必ずしも共通の振る舞いを持つとは限らない場合に使用する

## 静的クエリの設計
GraphQLでは、クエリを直接文字列として記述する「静的クエリ（static query）」の設計が推奨されている。
なぜ静的クエリが良いのか？

* コードの可読性が向上する
  * 静的クエリなら、ソースコードを見ただけでどのフィールドが必要なのか、どのような形のデータが返ってくるのかが一目瞭然
* ツールの恩恵を受けられる
  * 静的なクエリは、IDEによる補完やエラーチェック、コード生成ツールとの連携が容易になる
* サーバーとの契約が明確になる
  * 静的クエリは変更されないため、デプロイ前にどのクエリが送信されるかを正確に把握でき、クライアントとサーバー間の契約が明確になる
* ログや解析が容易になる
  * クエリに名前を付けておくと、サーバー側でのログ収集や、どのクエリが頻繁に使われているかの解析がシンプルになる

## Mutation
### Relayの慣習
各Mutationに対して「ひとつの必須の入力型（input type）」を使うことが推奨される。

**メリット**
* 進化しやすい（Evolvability）
  * ひとつのinput型にまとめることで、後からフィールドを追加・変更する際、Mutation自体のシグネチャを大きく変える必要がなくなる。
* クライアント側が使いやすい
  * 複数の引数を個別に渡すのではなく、ひとつの変数（inputオブジェクト）で済むため、クライアント側のコードがシンプルになる。
* APIの一貫性
  * 同じパターンを使うことで、API全体での統一感が生まれ、他のAPIと合わせて理解しやすくなる。

## エラー
### エラーに含まれる情報
* message: エラーの内容を説明する文字列
* locations: クエリ内のエラー発生箇所（行や列）
* path: どのフィールドでエラーが起きたかを示すパス
* extensions: エラーコードなど追加情報を入れるためのフィールド

### エラーの種類
* 開発者／クライアントエラー
  * ネットワークのタイムアウト、IDの形式が正しくない、レート制限など、クライアント側が対処するべきエラー等
  * これらはGraphQLのerrorsフィールドに含まれ、開発者がデバッグやロギングに利用する。
* ユーザーエラー
  * 例えば、「メールアドレスが既に使われています」や「チェックアウトを二重に行おうとした」など、ビジネスルールに基づくエラー
  * これらはエラーとしてレスポンスのerrorsに入れると、Mutation全体がnullになってしまい、クライアントにデータが返せなくなる
  * そのため、**ユーザーエラーはGraphQLスキーマの一部として、Mutationのペイロードにエラー情報を含める設計が推奨される。**
