# スキーマ設計
## Naming
* 命名の一貫性が重要
* クライアントが予測可能な名称にする
* 使用する名詞や動詞に一貫性を持たせるべき
* できるだけ具体的にしてクライアントの混乱を避ける
  * 「User」や「Event」のような一般的または汎用的な名前は良くない

## Descriptions
* スキーマがよく設計されていれば、descriptionsはほとんど不要のはず
* ユーザーのユースケースに対する理解をdescriptionsに依存させないことが重要

## スキーマを使いやすく・理解しやすくする方法
* 可能な限りフィールドは1つのことに特化する。
* スキーマが強制できる場合は、サーバーサイド実行時ロジック（バリデーションや変換）を避ける。
  * enumを利用して許容する状態を明確にする
  * nullが許容できない場合は!をつける
* デフォルト値を使用して、オプションの入力や引数を使用する際のデフォルトの動作を示す。

## ページネーション
* オフセット
  * 「何件目から何件取得するか」を指定する方法
  * データの更新でページ間の整合性が崩れる可能性有

* カーソル（通常はこちらで実装すべき）
  * 各アイテムに一意の識別子（カーソル）を付与し、そのカーソル以降のデータを取得する方法
  * データが変動してもズレが生じない

## 「nullを許容するかどうか」を決める際のガイドライン
* 引数について
  * 基本的に、引数は必ず値が渡されるように（non-null）すると、APIが予測しやすくなり、使いやすくなる
  * ただし、新しく引数を追加する場合は、既存のクライアントを壊さないようにnullableにするのがベスト
* データ取得に失敗する可能性があるフィールド
  * データベースの関連付けやネットワーク呼び出しなど、将来エラーが起こりうるフィールドは、失敗時にnullを返せるようにnullableにしておくと安全
* すでに親オブジェクトでロード済みのシンプルなスカラー値
  * 実行時にすでに値が存在することが保証されているため、non-nullにしても問題ない

## Abstract Types
### インターフェース
* 振る舞いを共有するものに対して共通の仕様（ルール）を提供するものであるべき
* 複数の型がいくつかのフィールドを共有しているが、これらの型が共通の振る舞いを共有していない場合、単にインターフェイスを混在させる誘惑を避けるべき
* 強い意味を持たないインターフェースの命名はぎこちなくなる

### ユニオン
あるフィールドが異なる型を返す可能性があるが、それらの型が必ずしも共通の振る舞いを持つとは限らない場合に使用する
